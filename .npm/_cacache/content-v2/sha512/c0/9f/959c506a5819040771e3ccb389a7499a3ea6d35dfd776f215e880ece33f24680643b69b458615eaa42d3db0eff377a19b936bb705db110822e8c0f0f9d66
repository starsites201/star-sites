{"_id":"@wasm-audio-decoders/opus-ml","name":"@wasm-audio-decoders/opus-ml","dist-tags":{"latest":"0.0.1"},"versions":{"0.0.1":{"name":"@wasm-audio-decoders/opus-ml","version":"0.0.1","description":"Web Assembly streaming Opus decoder with Machine Learning enhancements","type":"module","main":"./index.js","exports":{"types":"./types.d.ts","default":"./index.js"},"sideEffects":false,"types":"types.d.ts","keywords":["Opus","audio","decoder","multichannel","surround","stream","streams","libopus","Web Assembly","Wasm","Web Worker","speech","machine learning"],"author":{"name":"Ethan Halsall","email":"ethanhalsall@pm.me"},"license":"MIT","bugs":{"url":"https://github.com/eshaz/wasm-audio-decoders/issues"},"homepage":"https://github.com/eshaz/wasm-audio-decoders/tree/master/src/opus-ml","repository":{"type":"git","url":"git+https://github.com/eshaz/wasm-audio-decoders.git","directory":"src/opus-ml"},"funding":{"type":"individual","url":"https://github.com/sponsors/eshaz"},"dependencies":{"@wasm-audio-decoders/common":"9.0.7"},"_id":"@wasm-audio-decoders/opus-ml@0.0.1","gitHead":"2f95b884eb0ceefdbeedbe245766cfe51ef91640","_nodeVersion":"22.15.0","_npmVersion":"11.3.0","dist":{"integrity":"sha512-FALuUCz10HS2h8KB4L7wmfXncOuBDFvlKRk6Ga2rw8sr/zNIpwCjhhomxH4JKPhVLOnBjZfrPa8aTFIQq74vzQ==","shasum":"5966904b1d0428de8ee9ef144ef2182dc1ad145b","tarball":"https://registry.npmjs.org/@wasm-audio-decoders/opus-ml/-/opus-ml-0.0.1.tgz","fileCount":9,"unpackedSize":8251919,"signatures":[{"keyid":"SHA256:DhQ8wR5APBvFHLF/+Tc+AYvPOdTpcIDqOhxsBHRwC7U","sig":"MEUCIQDY5KWh7CGWvmRPG9HdFGkZ5XT9AeAmvOsB4X76WBrISwIgCC7siK58z2PVDibDg3vG34v8AY50+8eumjRaBv8EUtY="}]},"_npmUser":{"name":"eshaz","email":"ethanshalsall@gmail.com"},"directories":{},"maintainers":[{"name":"eshaz","email":"ethanshalsall@gmail.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages-npm-production","tmp":"tmp/opus-ml_0.0.1_1746928977235_0.7745263597363854"},"_hasShrinkwrap":false}},"time":{"created":"2025-05-11T02:02:57.120Z","0.0.1":"2025-05-11T02:02:57.537Z","modified":"2025-05-11T02:02:57.857Z"},"maintainers":[{"name":"eshaz","email":"ethanshalsall@gmail.com"}],"description":"Web Assembly streaming Opus decoder with Machine Learning enhancements","homepage":"https://github.com/eshaz/wasm-audio-decoders/tree/master/src/opus-ml","keywords":["Opus","audio","decoder","multichannel","surround","stream","streams","libopus","Web Assembly","Wasm","Web Worker","speech","machine learning"],"repository":{"type":"git","url":"git+https://github.com/eshaz/wasm-audio-decoders.git","directory":"src/opus-ml"},"author":{"name":"Ethan Halsall","email":"ethanhalsall@pm.me"},"bugs":{"url":"https://github.com/eshaz/wasm-audio-decoders/issues"},"license":"MIT","readme":"# `@wasm-audio-decoders/opus-ml`\n\n`@wasm-audio-decoders/opus-ml` is a Web Assembly Opus audio decoder compiled with machine learning enhancements.\n  * 3.9 MiB minified bundle size\n  * Uses the latest [Opus 1.5 machine learning enhancements](https://opus-codec.org/demo/opus-1.5/) for high quality speech decoding\n  * Browser and NodeJS support (WASM SIMD support required)\n  * Built in Web Worker support\n  * Multichannel decoding (up to 255 channels)\n  * Based on [`libopus`](https://github.com/xiph/opus)\n  * **Notes**\n    * Web Assembly SIMD instruction support is required for this library. Please use [`opus-decoder`](https://github.com/eshaz/wasm-audio-decoders/tree/main/src/opus-decoder) or [`ogg-opus-decoder`](https://github.com/eshaz/wasm-audio-decoders/tree/main/src/ogg-opus-decoder) if your platform does not support SIMD.\n    * For a smaller library, see [`opus-decoder`](https://github.com/eshaz/wasm-audio-decoders/tree/main/src/opus-decoder) which is compiled without the machine learning enhancements.\n\nThis library is intended for users that already have Opus frames extracted from a container, i.e. (Ogg, Matroska (WEBM), or ISOBMFF (mp4)). See [`ogg-opus-decoder`](https://github.com/eshaz/wasm-audio-decoders/tree/main/src/ogg-opus-decoder) if you have an Ogg Opus file to decode.\n\nSee the [homepage](https://github.com/eshaz/wasm-audio-decoders) of this repository for more Web Assembly audio decoders like this one.\n\n### [Checkout the demo here](https://eshaz.github.io/wasm-audio-decoders/)\n\n## Installing\n* Install from [NPM](https://www.npmjs.com/package/opus-ml).\n\n  Run `npm i opus-ml`\n\n  ```javascript\n  import { OpusMLDecoder } from '@wasm-audio-decoders/opus-ml';\n\n  const decoder = new OpusMLDecoder();\n  ```\n \n* Or download the [build](https://github.com/eshaz/wasm-audio-decoders/tree/master/src/opus-ml/dist) and include it as a script.\n  ```html\n  <script src=\"opus-ml-decoder.min.js\"></script>\n  <script>\n    const decoder = new window[\"opus-ml\"].OpusMLDecoder();\n  </script>\n  ```\n\n## Usage\n\n1. Create a new instance and wait for the WASM to finish compiling. Decoding can be done on the main thread synchronously, or in a webworker asynchronously.\n\n   **Main thread synchronous decoding**\n   ```javascript\n   import { OpusMLDecoder } from '@wasm-audio-decoders/opus-ml';\n\n   const decoder = new OpusMLDecoder();\n\n   // wait for the WASM to be compiled\n   await decoder.ready;\n   ```\n\n   **Web Worker asynchronous decoding**\n   ```javascript\n   import { OpusMLDecoderWebWorker } from '@wasm-audio-decoders/opus-ml';\n\n   const decoder = new OpusMLDecoderWebWorker();\n\n   // wait for the WASM to be compiled\n   await decoder.ready;\n   ```\n\n1. Begin decoding Opus frames.\n\n   ```javascript  \n   // Decode an individual Opus frame\n   const {channelData, samplesDecoded, sampleRate} = decoder.decodeFrame(opusFrame);\n   \n   // Decode an array of individual Opus frames\n   const {channelData, samplesDecoded, sampleRate} = decoder.decodeFrames(opusFrameArray);\n   ```\n\n1. When done decoding, reset the decoder to decode a new stream, or free up the memory being used by the WASM module if you have no more audio to decode. \n\n   ```javascript\n   // `reset()` clears the decoder state and allows you do decode a new stream of Opus frames.\n   await decoder.reset();\n\n   // `free()` de-allocates the memory used by the decoder. You will need to create a new instance after calling `free()` to start decoding again.\n   decoder.free();\n   ```\n\n## API\nDecoded audio is always returned in the below structure.\n\n```javascript\n{\n    channelData: [\n      leftAudio, // Float32Array of PCM samples for the left channel\n      rightAudio, // Float32Array of PCM samples for the right channel\n      ... // additional channels\n    ],\n    samplesDecoded: 1234, // number of PCM samples that were decoded per channel\n    sampleRate: 48000, // sample rate of the decoded PCM\n    errors: [ // array containing descriptions for any decode errors\n      {\n        message: \"libopus -4 OPUS_INVALID_PACKET: The compressed data passed is corrupted\",\n        frameLength: 400, // length of the frame or data in bytes that encountered an error\n        frameNumber: 21, // position of error relative to total frames decoded \n        inputBytes: 4905, // position of error relative to total input bytes\n        outputSamples: 18888, // position of error relative to total output samples\n      }\n    ]\n}\n```\n\nEach Float32Array within `channelData` can be used directly in the WebAudio API for playback.\n\nDecoding will proceed through any errors. Any errors encountered may result in gaps in the decoded audio.\n\n### Multichannel Output\n\nEach channel is assigned to a speaker location in a conventional surround arrangement. Specific locations depend on the number of channels, and are given below in order of the corresponding channel indices. This set of surround options and speaker location orderings is the same as those used by the Vorbis codec.\n\n* 1 channel: monophonic (mono).\n* 2 channels: stereo (left, right).\n* 3 channels: linear surround (left, center, right).\n* 4 channels: quadraphonic (front left, front right, rear left, rear right).\n* 5 channels: 5.0 surround (front left, front center, front right, rear left, rear right).\n* 6 channels: 5.1 surround (front left, front center, front right, rear left, rear right, LFE).\n* 7 channels: 6.1 surround (front left, front center, front right, side left, side right, rear center, LFE).\n* 8 channels: 7.1 surround (front left, front center, front right, side left, side right, rear left, rear right, LFE).\n* 9-255 channels: No mapping is defined.\n\nSee: https://datatracker.ietf.org/doc/html/rfc7845.html#section-5.1.1.2\n\nEach Float32Array within `channelData` can be used directly in the WebAudio API for playback.\n\n## `OpusMLDecoder`\n\nClass that decodes Opus frames synchronously on the main thread.\n\n### Options\n```javascript\nconst decoder = new OpusMLDecoder({\n  speechQualityEnhancement: \"nolace\",\n  forceStereo: false,\n  sampleRate: 48000,\n  preSkip: 0,\n  channels: 2,\n  streamCount: 1,\n  coupledStreamCount: 1,\n  channelMappingTable: [0, 1]\n});\n```\n\n#### **The below options should be obtained from the Opus Header.**\nSee this [documentation](https://wiki.xiph.org/OggOpus#ID_Header) on the Opus header for more information. If you don't have access to the Opus header, the default values will successfully decode most stereo Opus streams.\n\n* `speechQualityEnhancement` *optional, defaults to `\"nolace\"`*\n  * `\"none\"`:\n    * Disables machine learning decoding.\n    * Normal quality, but fastest.\n  * `\"lace\"`:\n    * Enables LACE machine learning decoding.\n    * Medium quality, but faster (complexity of 100 MFLOPS)\n  * `\"nolace\"`: (default)\n    * Enables Non-Linear LACE machine learning decoding.\n    * Best quality, but slower (complexity of 400 MFLOPS).\n  * See the [opus-1.5 release notes](https://opus-codec.org/demo/opus-1.5/) for more information about machine learning decoding.\n* `forceStereo` *optional, defaults to `false`*\n  * Set to `true` to force stereo output when decoding mono or multichannel Ogg Opus.\n  * If there are more than 8 channels, this option is ignored.\n* `preSkip` *optional, defaults to `0`*\n  * Number of samples to skip at the beginning reported by the Opus header.\n* `sampleRate` *optional, defaults to `48000`*\n  * Sample rate the decoder will output.\n  * Valid sample rates: `8000, 12000, 16000, 24000, or 48000`\n#### ***Required for Multichannel Decoding.** (Channel Mapping Family >= 1)*\n* `channels` *optional, defaults to `2`*\n  * Number of channels reported by the Opus header.\n* `streamCount` *optional, defaults to `1`*\n  * Number of streams reported by the Opus header.\n* `coupledStreamCount` *optional, defaults to: `1` when 2 channels, `0` when 1 channel*\n  * Number of coupled streams reported by the Opus header.\n* `channelMappingTable` *optional, defaults to `[0, 1]` when 2 channels, `[0]` when 1 channel*\n  * Channel mapping reported by the Opus header.\n\n### Getters\n* `decoder.ready` *async*\n  * Returns a promise that is resolved when the WASM is compiled and ready to use.\n\n### Methods\n\n* `decoder.decodeFrame(opusFrame)`\n  * `opusFrame` Uint8Array containing a single Opus frame.\n  * Returns decoded audio.\n* `decoder.decodeFrames(opusFrames)`\n  * `opusFrames` Array of Uint8Arrays containing Opus frames.\n  * Returns decoded audio.\n* `decoder.reset()` *async*\n  * Resets the decoder so that a new stream of Opus frames can be decoded.\n* `decoder.free()`\n  * De-allocates the memory used by the decoder.\n  * After calling `free()`, the current instance is made unusable, and a new instance will need to be created to decode additional Opus frames.\n\n## `OpusMLDecoderWebWorker`\n\nClass that decodes Opus frames asynchronously within a web worker. Decoding is performed in a separate, non-blocking thread. Each new instance spawns a new worker allowing you to run multiple workers for concurrent decoding of multiple streams.\n\n### Options\n```javascript\nconst decoder = new OpusMLDecoderWebWorker({ \n  speechQualityEnhancement: \"nolace\",\n  forceStereo: false,\n  sampleRate: 48000,\n  channels: 2,\n  streamCount: 1,\n  coupledStreamCount: 1,\n  channelMappingTable: [0, 1]\n});\n```\n\n#### **The below options should be obtained from the Opus Header.**\nSee this [documentation](https://wiki.xiph.org/OggOpus#ID_Header) on the Opus header for more information. If you don't have access to the Opus header, the default values will successfully decode most stereo Opus streams.\n\n* `speechQualityEnhancement` *optional, defaults to `\"nolace\"`*\n  * `\"none\"`:\n    * Disables machine learning decoding.\n    * Normal quality, but fastest.\n  * `\"lace\"`:\n    * Enables LACE machine learning decoding.\n    * Medium quality, but faster (complexity of 100 MFLOPS)\n  * `\"nolace\"`: (default)\n    * Enables Non-Linear LACE machine learning decoding.\n    * Best quality, but slower (complexity of 400 MFLOPS).\n  * See the [opus-1.5 release notes](https://opus-codec.org/demo/opus-1.5/) for more information about machine learning decoding.\n* `forceStereo` *optional, defaults to `false`*\n  * Set to `true` to force stereo output when decoding mono or multichannel Ogg Opus.\n  * If there are more than 8 channels, this option is ignored.\n* `preSkip` *optional, defaults to `0`*\n  * Number of samples to skip at the beginning reported by the Opus header.\n* `sampleRate` *optional, defaults to `48000`*\n  * Sample rate the decoder will output.\n  * Valid sample rates: `8000, 12000, 16000, 24000, or 48000`\n#### ***Required for Multichannel Decoding.** (Channel Mapping Family >= 1)*\n* `channels` *optional, defaults to `2`*\n  * Number of channels reported by the Opus header.\n* `streamCount` *optional, defaults to `1`*\n  * Number of streams reported by the Opus header.\n* `coupledStreamCount` *optional, defaults to: `1` when 2 channels, `0` when 1 channel*\n  * Number of coupled streams reported by the Opus header.\n* `channelMappingTable` *optional, defaults to `[0, 1]` when 2 channels, `[0]` when 1 channel*\n  * Channel mapping reported by the Opus header.\n### Getters\n* `decoder.ready` *async*\n  * Returns a promise that is resolved when the WASM is compiled and ready to use.\n\n### Methods\n\n* `decoder.decodeFrame(opusFrame)` *async*\n  * `opusFrame` Uint8Array containing a single Opus frame.\n  * Returns a promise that resolves with the decoded audio.\n* `decoder.decodeFrames(opusFrames)` *async*\n  * `opusFrames` Array of Uint8Arrays containing Opus frames.\n  * Returns a promise that resolves with the decoded audio.\n* `decoder.reset()` *async*\n  * Resets the decoder so that a new stream of Opus frames can be decoded.\n* `decoder.free()` *async*\n  * De-allocates the memory used by the decoder and terminates the web worker.\n  * After calling `free()`, the current instance is made unusable, and a new instance will need to be created to decode additional Opus frames.\n\n### Properly using the Web Worker interface\n\n`OpusMLDecoderWebWorker` uses async functions to send operations to the web worker without blocking the main thread. To fully take advantage of the concurrency provided by web workers, your code should avoid using `await` on decode operations where it will block the main thread.\n\nEach method call on a `OpusMLDecoderWebWorker` instance will queue up an operation to the web worker. Operations will complete within the web worker thread one at a time and in the same order in which the methods were called.\n\n  * **Good** Main thread is not blocked during each decode operation. The example `playAudio` function is called when each decode operation completes. Also, the next decode operation can begin while `playAudio` is doing work on the main thread.\n    ```javascript\n    const playAudio = ({ channelData, samplesDecoded, sampleRate }) => {\n      // does something to play the audio data.\n    }\n\n    decoder.decodeFrame(frameData1).then(playAudio);\n    decoder.decodeFrame(frameData2).then(playAudio);\n    decoder.decodeFrame(frameData3).then(playAudio);\n\n    // do some other operations while the audio is decoded\n    ```\n\n  * **Bad** Main thread is being blocked by `await` during each decode operation. Synchronous code is halted while decoding completes, negating the benefits of using a webworker.\n    ```javascript\n    const decoded1 = await decoder.decodeFrame(frameData1); // blocks the main thread\n    playAudio(decoded1);\n\n    const decoded2 = await decoder.decodeFrame(frameData2); // blocks the main thread\n    playAudio(decoded2);\n\n    const decoded3 = await decoder.decodeFrame(frameData3); // blocks the main thread\n    playAudio(decoded3);\n    ```","readmeFilename":"README.md","_rev":"1-e3bff9a189256391f01f515fe5706bb5"}